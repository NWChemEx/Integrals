#include <Integrals/TwoCTensorBuilder.hpp>

#include "TestCommon.hpp"

std::vector<double> corr={
1.0464370899978459,
3.4291996305312606,
0.0000000000000000,
0.0000000000000000,
0.0000000000000000,
2.6052624057150808,
2.6052624057150808,
3.4291996305312606,
26.4352252164276713,
0.0000000000000000,
-0.0000000000000002,
0.0000000000000000,
25.3420821293274017,
25.3420821293274017,
0.0000000000000000,
0.0000000000000000,
5.7847978365504300,
0.0000000000000000,
0.0000000000000000,
4.2141100538676941,
-4.2141100538676941,
0.0000000000000000,
-0.0000000000000002,
0.0000000000000000,
5.7847978365504300,
0.0000000000000000,
3.2924421173969129,
3.2924421173969129,
0.0000000000000000,
0.0000000000000000,
0.0000000000000000,
0.0000000000000000,
5.7847978365504300,
0.0000000000000000,
0.0000000000000000,
2.6052624057150808,
25.3420821293274017,
4.2141100538676941,
3.2924421173969129,
0.0000000000000000,
39.9325707858561643,
26.6712894368539963,
2.6052624057150808,
25.3420821293274017,
-4.2141100538676941,
3.2924421173969129,
0.0000000000000000,
26.6712894368539963,
39.9325707858561643
};

TEST_CASE("Testing MetricTensorBuilder"){
    
    auto molecule=make_molecule();
    auto bs=molecule.get_basis("sto-3gfile");

    std::vector<LibChemist::BasisSet> basissets({bs,bs});    

    Integrals::TwoCTensorBuilder<nwx_libint::Metric> metric_build;
    auto metric_tensor = metric_build.compute(molecule,basissets);

    size_t counter = 0;
    for (size_t i = 0; i < metric_tensor[0].dimension(0); i++)
        for (size_t j = 0; j < metric_tensor[0].dimension(1); j++) {
            REQUIRE(metric_tensor[0](i,j) == Approx(corr[counter]).epsilon(eps).margin(marg));
            counter++;
        }
    
    std::vector<LibChemist::BasisSet> badsets({bs,bs,bs});  
    REQUIRE_THROWS_AS(metric_build.compute(molecule,badsets), std::length_error);  
}
