/*
 * Copyright 2026 NWChemEx-Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "../libint/test_error.hpp"
#include <integrals/utils/rank2_shell_norm.hpp>

using namespace integrals::libint::test;
using namespace integrals::utils;

using eri_pt    = simde::ERI4;
using size_type = std::size_t;
using Catch::Approx;
using tensorwrapper::buffer::make_contiguous;

/* Testing notes.
 *
 * All correct answers were generated by using a Python script. Since the
 * script basically does the same thing as the C++ code, there is a chance we
 * have replicated the same error in both places. However, since the Python
 * script uses a different mechanism (i.e., Numpy) this is less likely. The
 * script is:
 *
 * ```
 * import numpy as np
 * eris = np.array(...) # Put ERI block here
 * norm2 = np.einsum('mnls,mnls->', eris, eris)
 * print(np.sqrt(norm2))
 * ```
 */

TEST_CASE("Rank2 Shell Norm") {
    pluginplay::ModuleManager mm;
    integrals::load_modules(mm);
    integrals::set_defaults(mm);

    auto eri_mod = mm.at("ERI4");

    auto [bra0, bra1, ket0, ket1] = get_h2_dimer_0312_bases();
    simde::type::aos_squared bra(bra0, bra1);
    simde::type::aos_squared ket(ket0, ket1);
    simde::type::v_ee_type v_ee{};

    // Initially we test one quartet at a time
    std::array<size_type, 4> offsets{0, 0, 0, 0};

    SECTION("(ss|ss)") {
        std::array<size_type, 4> naos{1, 1, 1, 1};
        chemist::braket::BraKet mnls(bra, v_ee, ket);
        auto I       = eri_mod.run_as<eri_pt>(mnls);
        auto& buffer = make_contiguous(I.buffer());
        auto norm    = rank2_shell_norm(buffer, offsets, naos);
        REQUIRE(norm == Approx(0.0002263495626484).epsilon(1.0e-8));
    }

    SECTION("(sp|ss)") {
        bra.second.ao_basis_set().shell(0).l() = 1;
        std::array<size_type, 4> naos{1, 3, 1, 1};
        chemist::braket::BraKet mnls(bra, v_ee, ket);
        auto I       = eri_mod.run_as<eri_pt>(mnls);
        auto& buffer = make_contiguous(I.buffer());
        auto norm    = rank2_shell_norm(buffer, offsets, naos);
        REQUIRE(norm == Approx(0.0007106429408912309).epsilon(1.0e-8));
    }

    SECTION("(sd|ps)") {
        bra.second.ao_basis_set().shell(0).l() = 2;
        ket.first.ao_basis_set().shell(0).l()  = 1;
        std::array<size_type, 4> naos{1, 6, 3, 1};
        chemist::braket::BraKet mnls(bra, v_ee, ket);
        auto I       = eri_mod.run_as<eri_pt>(mnls);
        auto& buffer = make_contiguous(I.buffer());
        auto norm    = rank2_shell_norm(buffer, offsets, naos);
        REQUIRE(norm == Approx(0.0021424444248565305).epsilon(1.0e-8));
    }

    SECTION("(sp|df)") {
        bra.second.ao_basis_set().shell(0).l() = 1;
        ket.first.ao_basis_set().shell(0).l()  = 2;
        ket.second.ao_basis_set().shell(0).l() = 3;
        std::array<size_type, 4> naos{1, 3, 6, 10};
        chemist::braket::BraKet mnls(bra, v_ee, ket);
        auto I       = eri_mod.run_as<eri_pt>(mnls);
        auto& buffer = make_contiguous(I.buffer());
        auto norm    = rank2_shell_norm(buffer, offsets, naos);
        REQUIRE(norm == Approx(0.0035472410738408154).epsilon(1.0e-8));
    }
}